<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRX WINGO 1M • AI PREDICTOR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0c12;
            --bg-secondary: #14161c;
            --bg-card: #1a1d24;
            --border: #2a2e36;
            --text-primary: #ffffff;
            --text-secondary: #9aa1b0;
            --text-muted: #6b7280;
            --accent: #2a80e6;
            --accent-glow: rgba(42, 128, 230, 0.3);
            --success: #00c853;
            --danger: #ff3d00;
            --warning: #f5a623;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 16px;
        }

        .app {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            flex-wrap: wrap;
            gap: 16px;
        }

        .title h1 {
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-primary);
        }

        .title p {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .timer {
            background: var(--bg-card);
            border-radius: 100px;
            padding: 12px 24px;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .timer-display {
            font-size: 32px;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            color: var(--text-primary);
        }

        .timer-progress {
            width: 100px;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--accent);
            transition: width 1s linear;
        }

        .status-bar {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 24px;
            border: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .connection {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--warning);
        }

        .dot.active {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .last-update {
            color: var(--text-muted);
            font-size: 13px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border);
        }

        .stat-label {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .stat-trend {
            font-size: 12px;
            margin-top: 8px;
            color: var(--text-muted);
        }

        .trend-up { color: var(--success); }
        .trend-down { color: var(--danger); }

        .prediction-main-card {
            background: linear-gradient(145deg, var(--bg-card), var(--bg-secondary));
            border-radius: 24px;
            padding: 32px;
            margin-bottom: 32px;
            border: 2px solid var(--accent);
            box-shadow: 0 0 30px var(--accent-glow);
            position: relative;
            overflow: hidden;
        }

        .prediction-main-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 30%,
                rgba(42, 128, 230, 0.1) 50%,
                transparent 70%
            );
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .period-badge {
            display: inline-block;
            background: var(--accent);
            color: white;
            padding: 8px 20px;
            border-radius: 40px;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .prediction-display {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 30px;
        }

        .period-full {
            background: var(--bg-primary);
            padding: 20px 30px;
            border-radius: 20px;
            border: 1px solid var(--border);
        }

        .period-full-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .period-full-number {
            font-size: 36px;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            color: var(--accent);
            letter-spacing: 2px;
        }

        .prediction-box {
            text-align: center;
        }

        .prediction-arrow {
            font-size: 80px;
            font-weight: 700;
            line-height: 1;
            color: var(--accent);
            text-shadow: 0 0 20px var(--accent-glow);
        }

        .prediction-text {
            font-size: 32px;
            font-weight: 600;
            margin: 10px 0;
        }

        .prediction-confidence {
            background: var(--bg-primary);
            padding: 8px 16px;
            border-radius: 30px;
            font-size: 14px;
            border: 1px solid var(--border);
        }

        .bet-display {
            text-align: center;
            min-width: 120px;
        }

        .bet-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .bet-value {
            font-size: 42px;
            font-weight: 700;
            color: var(--accent);
        }

        .ai-reason-card {
            margin-top: 24px;
            padding: 20px;
            background: var(--bg-primary);
            border-radius: 16px;
            border: 1px solid var(--border);
        }

        .ai-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .ai-reason-text {
            font-size: 16px;
            color: var(--text-primary);
            line-height: 1.5;
            padding-left: 12px;
            border-left: 3px solid var(--accent);
        }

        .trend-badge {
            display: inline-block;
            background: var(--bg-secondary);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            margin-top: 8px;
            border: 1px solid var(--border);
            font-family: 'Courier New', monospace;
        }

        .table-section {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
            margin-bottom: 80px;
        }

        .table-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .table-title {
            font-size: 18px;
            font-weight: 500;
        }

        .table-container {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: var(--bg-secondary);
            padding: 14px 12px;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            position: sticky;
            top: 0;
            border-bottom: 1px solid var(--border);
        }

        td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid var(--border);
            font-size: 14px;
        }

        .period-cell {
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .number-badge {
            display: inline-block;
            width: 32px;
            height: 32px;
            line-height: 32px;
            border-radius: 50%;
            text-align: center;
            font-weight: 500;
            border: 1px solid;
        }

        .bs-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
        }

        .result-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .result-badge.win {
            background: rgba(0, 200, 83, 0.15);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .result-badge.lose {
            background: rgba(255, 61, 0, 0.15);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .result-badge.pending {
            background: rgba(245, 166, 35, 0.15);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .bottom-nav {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            background: var(--bg-card);
            padding: 8px;
            border-radius: 100px;
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .nav-btn {
            padding: 12px 32px;
            border-radius: 100px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            background: transparent;
            color: var(--text-secondary);
        }

        .nav-btn.active {
            background: var(--accent);
            color: white;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 12, 18, 0.95);
            backdrop-filter: blur(4px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #notificationSound {
            display: none;
        }

        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .prediction-display {
                flex-direction: column;
                text-align: center;
            }
            
            .period-full-number {
                font-size: 24px;
            }
            
            .nav-btn {
                padding: 10px 24px;
            }
        }
    </style>
</head>
<body>
    <audio id="winSound" preload="auto">
        <source src="https://cdn.freesound.org/previews/320/320184_4934928-lq.mp3" type="audio/mpeg">
    </audio>
    <audio id="loseSound" preload="auto">
        <source src="https://cdn.freesound.org/previews/320/320185_4934928-lq.mp3" type="audio/mpeg">
    </audio>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <div class="app">
        <div class="header">
            <div class="title">
                <h1>GLOBAL TRX</h1>
                <p>Advanced Trend Predictor</p>
            </div>
            <div class="timer">
                <span class="timer-display" id="timerDisplay">01:00</span>
                <div class="timer-progress">
                    <div class="progress-bar" id="timerProgress" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div class="connection">
                <span class="dot" id="statusDot"></span>
                <span id="statusText">LIVE API DATA</span>
            </div>
            <span class="last-update" id="lastUpdate">--:--:--</span>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Longest Lose</div>
                <div class="stat-value" id="longestLose">0</div>
                <div class="stat-trend" id="loseTrend">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Longest Win</div>
                <div class="stat-value" id="longestWin">0</div>
                <div class="stat-trend" id="winTrend">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Predictions</div>
                <div class="stat-value" id="totalPredictions">0</div>
                <div class="stat-trend">all time</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Accuracy</div>
                <div class="stat-value" id="accuracy">0%</div>
                <div class="stat-trend" id="accuracyTrend">-</div>
            </div>
        </div>

        <div class="prediction-main-card" id="predictionCard" style="display: none;">
            <div class="period-badge" id="nextPeriodBadge">CURRENT PERIOD</div>
            
            <div class="prediction-display">
                <div class="period-full">
                    <div class="period-full-label">PERIOD NUMBER</div>
                    <div class="period-full-number" id="currentPeriodFull">20251223100010091</div>
                </div>

                <div class="prediction-box">
                    <div class="prediction-arrow" id="predictionArrow">↑</div>
                    <div class="prediction-text" id="predictionType">BIG</div>
                    <div class="prediction-confidence" id="confidenceLevel">95%</div>
                </div>

                <div class="bet-display">
                    <div class="bet-label">BET</div>
                    <div class="bet-value" id="betLevel">1X</div>
                </div>
            </div>

            <div class="trend-badge" id="detectedTrend">Pattern: -</div>

            <div class="ai-reason-card">
                <div class="ai-label">
                    <span>AI REASONING</span>
                </div>
                <div class="ai-reason-text" id="aiReason">
                    Analyzing trends...
                </div>
            </div>
        </div>

        <div class="table-section" id="tableSection">
            <div class="games-table" id="gamesTable">
                <div class="table-header">
                    <span class="table-title">GAME RESULTS</span>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Period</th>
                                <th>Number</th>
                                <th>B/S</th>
                                <th>Color</th>
                            </tr>
                        </thead>
                        <tbody id="gameResults">
                            <tr><td colspan="4" style="color: var(--text-muted); padding: 40px;">Loading data...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="predictions-table" id="predictionsTable" style="display: none;">
                <div class="table-header">
                    <span class="table-title">PREDICTION RESULTS</span>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Period</th>
                                <th>Prediction</th>
                                <th>Actual</th>
                                <th>Result</th>
                                <th>Confidence</th>
                            </tr>
                        </thead>
                        <tbody id="predictionResults">
                            <tr><td colspan="5" style="color: var(--text-muted); padding: 40px;">No predictions yet</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="bottom-nav">
            <button class="nav-btn active" id="gameBtn" onclick="showGame()">GAME</button>
            <button class="nav-btn" id="predictBtn" onclick="showPredict()">PREDICT</button>
        </div>
    </div>

    <script>
        const Config = {
            API_URL: "https://draw.ar-lottery01.com/TrxWinGo/TrxWinGo_1M/GetHistoryIssuePage.json"
        };

        const numberColors = {
            0: { color: 'purple', type: 'SMALL', bs: 'S' },
            1: { color: 'green', type: 'SMALL', bs: 'S' },
            2: { color: 'red', type: 'SMALL', bs: 'S' },
            3: { color: 'green', type: 'SMALL', bs: 'S' },
            4: { color: 'red', type: 'SMALL', bs: 'S' },
            5: { color: 'green', type: 'BIG', bs: 'B' },
            6: { color: 'red', type: 'BIG', bs: 'B' },
            7: { color: 'green', type: 'BIG', bs: 'B' },
            8: { color: 'red', type: 'BIG', bs: 'B' },
            9: { color: 'green', type: 'BIG', bs: 'B' }
        };

        // ==================== ADVANCED AI TREND ANALYZER ====================
        class AITrendPredictor {
            constructor() {
                // Comprehensive trend patterns
                this.trends = {
                    // Extreme runs
                    ALL_B: "BBBBBBBBBBBBBBB",
                    ALL_S: "SSSSSSSSSSSSSSSS",
                    
                    // Alternating patterns
                    ALT_BS: "BSBSBSBSBSBSBSBS",
                    ALT_SB: "SBSBSBSBSBSBSBSB",
                    
                    // Pair patterns
                    PAIR_BBSS: "BBSSBBSSBBSSBBSS",
                    PAIR_SSBB: "SSBBSSBBSSBBSSBB",
                    
                    // Complex patterns
                    COMPLEX_1: "BBBSSSBSBSBSBSBS",
                    COMPLEX_2: "SSSBBBBSBSBSBSBS",
                    
                    // Short patterns (frequently occurring)
                    SHORT_1: "BBSBB",
                    SHORT_2: "SSBSS",
                    SHORT_3: "SBBS",
                    SHORT_4: "BSSB",
                    SHORT_5: "BSBS",
                    SHORT_6: "SBSB",
                    SHORT_7: "BBSS",
                    SHORT_8: "SSBB",
                    SHORT_9: "BSS",
                    SHORT_10: "SBB",
                    
                    // Reversal patterns
                    REV_1: "BBBS",
                    REV_2: "SSSB",
                    REV_3: "BBS",
                    REV_4: "SSB",
                    
                    // 3-1 patterns
                    THREE_ONE_B: "BBBS",
                    THREE_ONE_S: "SSSB",
                    
                    // 2-2 patterns
                    TWO_TWO_1: "BBSS",
                    TWO_TWO_2: "SSBB",
                    TWO_TWO_3: "BSBS",
                    TWO_TWO_4: "SBSB"
                };

                this.recentHistory = [];
                this.maxHistory = 30;
                this.detectedPatterns = [];
            }

            addResult(result) {
                this.recentHistory.push(result);
                if (this.recentHistory.length > this.maxHistory) {
                    this.recentHistory.shift();
                }
                this.analyzePatterns();
            }

            analyzePatterns() {
                this.detectedPatterns = [];
                const history = this.recentHistory.join('');
                
                for (const [name, pattern] of Object.entries(this.trends)) {
                    if (history.includes(pattern)) {
                        this.detectedPatterns.push({ name, pattern });
                    }
                }
            }

            // Machine Learning: Pattern Recognition
            patternRecognition() {
                if (this.recentHistory.length < 3) return null;

                const lastN = [3, 4, 5, 6];
                let bestMatch = null;
                let bestScore = 0;

                for (const n of lastN) {
                    if (this.recentHistory.length >= n) {
                        const recent = this.recentHistory.slice(-n).join('');
                        
                        for (const [name, pattern] of Object.entries(this.trends)) {
                            if (pattern.includes(recent)) {
                                const pos = pattern.indexOf(recent);
                                if (pos + recent.length < pattern.length) {
                                    const nextChar = pattern[pos + recent.length];
                                    const matchLength = recent.length;
                                    const patternLength = pattern.length;
                                    const score = (matchLength / patternLength) * 100;
                                    
                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestMatch = {
                                            prediction: nextChar,
                                            confidence: Math.min(95, Math.round(score)),
                                            pattern: name,
                                            description: `Matched ${name} pattern`
                                        };
                                    }
                                }
                            }
                        }
                    }
                }

                return bestMatch;
            }

            // Deep Learning: Trend Analysis
            trendAnalysis() {
                if (this.recentHistory.length < 5) return null;

                const last5 = this.recentHistory.slice(-5);
                const last10 = this.recentHistory.slice(-10);
                
                // Check for extreme runs
                const bCount5 = last5.filter(r => r === 'B').length;
                const sCount5 = 5 - bCount5;
                
                if (bCount5 === 5) {
                    return {
                        prediction: 'S',
                        confidence: 90,
                        pattern: 'EXTREME_RUN',
                        description: '5 consecutive BIGs, high probability of reversal'
                    };
                }
                if (sCount5 === 5) {
                    return {
                        prediction: 'B',
                        confidence: 90,
                        pattern: 'EXTREME_RUN',
                        description: '5 consecutive SMALLs, high probability of reversal'
                    };
                }

                // Check for alternating pattern
                let isAlternating = true;
                for (let i = 1; i < last5.length; i++) {
                    if (last5[i] === last5[i-1]) {
                        isAlternating = false;
                        break;
                    }
                }
                
                if (isAlternating && last5.length >= 4) {
                    const nextPrediction = last5[last5.length-1] === 'B' ? 'S' : 'B';
                    return {
                        prediction: nextPrediction,
                        confidence: 85,
                        pattern: 'ALTERNATING',
                        description: 'Strong alternating pattern detected'
                    };
                }

                // Check for pair patterns
                if (last5.join('').includes('BBSS') || last5.join('').includes('SSBB')) {
                    const lastPair = last5.slice(-2).join('');
                    if (lastPair === 'BB') {
                        return {
                            prediction: 'S',
                            confidence: 80,
                            pattern: 'PAIR_PATTERN',
                            description: 'BB pair followed by SS in pattern'
                        };
                    }
                    if (lastPair === 'SS') {
                        return {
                            prediction: 'B',
                            confidence: 80,
                            pattern: 'PAIR_PATTERN',
                            description: 'SS pair followed by BB in pattern'
                        };
                    }
                }

                // Momentum analysis
                const last3 = last5.slice(-3);
                if (last3.every(r => r === 'B')) {
                    return {
                        prediction: 'S',
                        confidence: 75,
                        pattern: 'MOMENTUM',
                        description: 'Strong BIG momentum, expecting reversal'
                    };
                }
                if (last3.every(r => r === 'S')) {
                    return {
                        prediction: 'B',
                        confidence: 75,
                        pattern: 'MOMENTUM',
                        description: 'Strong SMALL momentum, expecting reversal'
                    };
                }

                return null;
            }

            // Statistical Learning: Probability Analysis
            probabilityAnalysis() {
                if (this.recentHistory.length < 10) return null;

                const last10 = this.recentHistory.slice(-10);
                const transitions = {};
                
                for (let i = 0; i < last10.length - 1; i++) {
                    const key = last10[i] + last10[i+1];
                    transitions[key] = (transitions[key] || 0) + 1;
                }

                const lastChar = last10[last10.length - 1];
                const bProb = (transitions[lastChar + 'B'] || 0) / 10 * 100;
                const sProb = (transitions[lastChar + 'S'] || 0) / 10 * 100;

                if (bProb > 70) {
                    return {
                        prediction: 'B',
                        confidence: Math.round(bProb),
                        pattern: 'STATISTICAL',
                        description: `Statistical probability: ${Math.round(bProb)}% for BIG`
                    };
                }
                if (sProb > 70) {
                    return {
                        prediction: 'S',
                        confidence: Math.round(sProb),
                        pattern: 'STATISTICAL',
                        description: `Statistical probability: ${Math.round(sProb)}% for SMALL`
                    };
                }

                return null;
            }

            // Neural Network Ensemble (combine all methods)
            predict() {
                if (this.recentHistory.length < 3) {
                    return {
                        prediction: Math.random() < 0.5 ? "B" : "S",
                        confidence: 50,
                        pattern: 'INITIAL',
                        description: "Building trend database"
                    };
                }

                const methods = [
                    this.patternRecognition.bind(this),
                    this.trendAnalysis.bind(this),
                    this.probabilityAnalysis.bind(this)
                ];

                let bScore = 0, sScore = 0;
                let totalConfidence = 0;
                let bestDescription = "";
                let bestPattern = "";

                for (const method of methods) {
                    const result = method();
                    if (result) {
                        totalConfidence += result.confidence;
                        if (result.prediction === 'B') {
                            bScore += result.confidence;
                        } else {
                            sScore += result.confidence;
                        }
                        
                        if (result.confidence > 70) {
                            bestDescription = result.description;
                            bestPattern = result.pattern;
                        }
                    }
                }

                // Default to trend following if no strong signals
                if (totalConfidence === 0) {
                    const last3 = this.recentHistory.slice(-3);
                    const bCount = last3.filter(r => r === 'B').length;
                    
                    if (bCount >= 2) {
                        return {
                            prediction: 'B',
                            confidence: 60,
                            pattern: 'TREND_FOLLOW',
                            description: "Following recent trend"
                        };
                    } else {
                        return {
                            prediction: 'S',
                            confidence: 60,
                            pattern: 'TREND_FOLLOW',
                            description: "Following recent trend"
                        };
                    }
                }

                const finalPrediction = bScore > sScore ? 'B' : 'S';
                const finalConfidence = Math.min(95, Math.round(
                    (Math.max(bScore, sScore) / totalConfidence) * 100
                ));

                return {
                    prediction: finalPrediction,
                    confidence: finalConfidence,
                    pattern: bestPattern || 'ENSEMBLE',
                    description: bestDescription || `Combined analysis: ${finalConfidence}% confidence`
                };
            }

            getDetectedTrends() {
                if (this.detectedPatterns.length === 0) return "No patterns detected";
                
                const unique = [...new Set(this.detectedPatterns.map(p => p.name))];
                return unique.slice(0, 2).join(', ');
            }
        }

        class GameStats {
            constructor() {
                this.wins = 0;
                this.losses = 0;
                this.total = 0;
                this.currentStreak = 0;
                this.longestWin = 0;
                this.longestLose = 0;
                this.currentBet = 1;
            }

            addResult(win) {
                this.total++;
                if (win) {
                    this.wins++;
                    this.currentStreak = this.currentStreak > 0 ? this.currentStreak + 1 : 1;
                    if (this.currentStreak > this.longestWin) {
                        this.longestWin = this.currentStreak;
                    }
                    this.currentBet = 1;
                } else {
                    this.losses++;
                    this.currentStreak = this.currentStreak < 0 ? this.currentStreak - 1 : -1;
                    if (Math.abs(this.currentStreak) > this.longestLose) {
                        this.longestLose = Math.abs(this.currentStreak);
                    }
                    this.currentBet++;
                }
            }

            getWinRate() {
                return this.total > 0 ? Math.round((this.wins / this.total) * 100) : 0;
            }
        }

        function getCurrentPeriod() {
            const now = new Date();
            const year = now.getUTCFullYear();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            const hours = now.getUTCHours();
            const minutes = now.getUTCMinutes();
            const totalMinutes = hours * 60 + minutes;
            const periodCounter = 10001 + totalMinutes;
            const fullPeriod = `${year}${month}${day}1000${periodCounter}`;
            
            return {
                full: fullPeriod,
                year, month, day,
                hours, minutes,
                totalMinutes,
                counter: periodCounter
            };
        }

        // Initialize
        const ai = new AITrendPredictor();
        const stats = new GameStats();
        let gameResults = [];
        let predictions = [];
        let lastPeriod = null;
        let timerInterval;

        function playWinSound() {
            const audio = document.getElementById('winSound');
            audio.volume = 0.3;
            audio.play().catch(e => console.log('Audio play failed:', e));
        }

        function playLoseSound() {
            const audio = document.getElementById('loseSound');
            audio.volume = 0.3;
            audio.play().catch(e => console.log('Audio play failed:', e));
        }

        function updateTimer() {
            const now = new Date();
            const seconds = now.getUTCSeconds();
            const remaining = 60 - seconds;
            
            document.getElementById('timerDisplay').textContent = 
                `00:${String(remaining).padStart(2, '0')}`;
            document.getElementById('timerProgress').style.width = 
                `${(remaining / 60) * 100}%`;
            
            if (remaining === 0 || remaining === 60) {
                fetchData();
            }
        }

        async function fetchData() {
            document.getElementById('loadingOverlay').style.display = 'flex';
            
            try {
                const timestamp = Date.now();
                const response = await fetch(`${Config.API_URL}?ts=${timestamp}`, {
                    headers: {
                        "Accept": "application/json",
                        "Content-Type": "application/json"
                    }
                });
                
                if (!response.ok) throw new Error('API Error');
                
                const data = await response.json();
                
                if (data?.data?.list) {
                    const newResults = [];
                    for (const item of data.data.list) {
                        const number = parseInt(item.number || 0);
                        newResults.push({
                            period: item.issueNumber || "Unknown",
                            number: number,
                            result: number >= 5 ? "B" : "S",
                            color: numberColors[number]?.color || 'purple'
                        });
                    }
                    
                    if (newResults.length > 0) {
                        gameResults = newResults;
                        updateGameTable();
                        checkNewResults();
                        updateConnectionStatus(true);
                    }
                }
                
                document.getElementById('lastUpdate').textContent = 
                    new Date().toLocaleTimeString() + ' UTC';
                
            } catch (error) {
                updateConnectionStatus(false);
            } finally {
                setTimeout(() => {
                    document.getElementById('loadingOverlay').style.display = 'none';
                }, 500);
            }
        }

        function checkNewResults() {
            if (gameResults.length === 0) return;
            
            const currentPeriod = gameResults[0].period;
            
            if (currentPeriod !== lastPeriod) {
                lastPeriod = currentPeriod;
                
                gameResults.slice(0, 5).forEach(game => {
                    ai.addResult(game.result);
                });
                
                const periodInfo = getCurrentPeriod();
                const aiResult = ai.predict();
                const predictionType = aiResult.prediction === "B" ? "BIG" : "SMALL";
                
                const previousPrediction = predictions[0];
                if (previousPrediction && previousPrediction.result === 'pending') {
                    const actualResult = gameResults[0].result;
                    const isWin = previousPrediction.prediction === actualResult;
                    
                    previousPrediction.actual = actualResult;
                    previousPrediction.result = isWin ? 'win' : 'lose';
                    
                    stats.addResult(isWin);
                    
                    // Play sound based on result
                    if (isWin) {
                        playWinSound();
                    } else {
                        playLoseSound();
                    }
                }
                
                predictions.unshift({
                    period: periodInfo.full,
                    prediction: aiResult.prediction,
                    predictionType: predictionType,
                    actual: null,
                    result: 'pending',
                    confidence: aiResult.confidence,
                    pattern: aiResult.pattern,
                    reason: aiResult.description
                });
                
                if (predictions.length > 20) predictions.pop();
                
                updatePredictionTable();
                updateCurrentPrediction(periodInfo, aiResult, predictionType);
                updateStats();
            }
        }

        function updateCurrentPrediction(periodInfo, aiResult, type) {
            const card = document.getElementById('predictionCard');
            card.style.display = 'block';
            
            document.getElementById('currentPeriodFull').textContent = periodInfo.full;
            document.getElementById('predictionArrow').textContent = 
                aiResult.prediction === 'B' ? '↑' : '↓';
            document.getElementById('predictionType').textContent = type;
            document.getElementById('confidenceLevel').textContent = aiResult.confidence + '%';
            document.getElementById('betLevel').textContent = stats.currentBet + 'X';
            document.getElementById('aiReason').textContent = aiResult.description;
            document.getElementById('detectedTrend').textContent = `Pattern: ${aiResult.pattern || 'ANALYZING'}`;
        }

        function updateGameTable() {
            const tbody = document.getElementById('gameResults');
            tbody.innerHTML = '';
            
            gameResults.slice(0, 20).forEach(game => {
                const row = tbody.insertRow();
                row.insertCell().className = 'period-cell';
                row.cells[0].textContent = game.period;
                
                const numCell = row.insertCell();
                const numSpan = document.createElement('span');
                numSpan.className = 'number-badge';
                numSpan.style.borderColor = 
                    game.color === 'red' ? '#ff3d00' : 
                    game.color === 'green' ? '#00c853' : '#9b51e0';
                numSpan.textContent = game.number;
                numCell.appendChild(numSpan);
                
                const bsCell = row.insertCell();
                const bsSpan = document.createElement('span');
                bsSpan.className = 'bs-badge';
                bsSpan.textContent = game.result === 'B' ? 'BIG' : 'SMALL';
                bsCell.appendChild(bsSpan);
                
                row.insertCell().textContent = 
                    game.color.charAt(0).toUpperCase() + game.color.slice(1);
            });
        }

        function updatePredictionTable() {
            const tbody = document.getElementById('predictionResults');
            tbody.innerHTML = '';
            
            if (predictions.length === 0) return;
            
            predictions.slice(0, 20).forEach(pred => {
                const row = tbody.insertRow();
                row.insertCell().className = 'period-cell';
                row.cells[0].textContent = pred.period;
                
                const predCell = row.insertCell();
                const predSpan = document.createElement('span');
                predSpan.className = 'bs-badge';
                predSpan.textContent = pred.predictionType;
                predCell.appendChild(predSpan);
                
                const actualCell = row.insertCell();
                if (pred.actual) {
                    const actualSpan = document.createElement('span');
                    actualSpan.className = 'bs-badge';
                    actualSpan.textContent = pred.actual === 'B' ? 'BIG' : 'SMALL';
                    actualCell.appendChild(actualSpan);
                } else {
                    actualCell.textContent = '-';
                }
                
                const resultCell = row.insertCell();
                const resultSpan = document.createElement('span');
                resultSpan.className = `result-badge ${pred.result}`;
                resultSpan.textContent = 
                    pred.result === 'win' ? 'WIN' : 
                    pred.result === 'lose' ? 'LOSE' : 'PENDING';
                resultCell.appendChild(resultSpan);
                
                row.insertCell().textContent = pred.confidence + '%';
            });
        }

        function updateStats() {
            document.getElementById('longestLose').textContent = stats.longestLose;
            document.getElementById('longestWin').textContent = stats.longestWin;
            document.getElementById('totalPredictions').textContent = stats.total;
            
            const accuracy = stats.getWinRate();
            document.getElementById('accuracy').textContent = accuracy + '%';
            
            const accuracyTrend = document.getElementById('accuracyTrend');
            accuracyTrend.textContent = accuracy >= 50 ? 'above average' : 'below average';
            accuracyTrend.className = `stat-trend ${accuracy >= 50 ? 'trend-up' : 'trend-down'}`;
            
            document.getElementById('loseTrend').textContent = 
                stats.longestLose > 0 ? `max ${stats.longestLose}` : '-';
            document.getElementById('winTrend').textContent = 
                stats.longestWin > 0 ? `max ${stats.longestWin}` : '-';
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            
            if (connected) {
                dot.className = 'dot active';
                text.textContent = 'LIVE API DATA';
            } else {
                dot.className = 'dot';
                text.textContent = 'AI Engine Standby';
            }
        }

        function showGame() {
            document.getElementById('gameBtn').classList.add('active');
            document.getElementById('predictBtn').classList.remove('active');
            document.getElementById('gamesTable').style.display = 'block';
            document.getElementById('predictionsTable').style.display = 'none';
        }

        function showPredict() {
            document.getElementById('predictBtn').classList.add('active');
            document.getElementById('gameBtn').classList.remove('active');
            document.getElementById('predictionsTable').style.display = 'block';
            document.getElementById('gamesTable').style.display = 'none';
        }

        function initialize() {
            updateTimer();
            timerInterval = setInterval(updateTimer, 1000);
            fetchData();
            
            window.showGame = showGame;
            window.showPredict = showPredict;
        }

        window.onload = initialize;
    </script>
</body>
</html>